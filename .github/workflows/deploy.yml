name: Deploy to Production

on:
  workflow_run:
    workflows: ["Build and Push Docker Images"]
    types:
      - completed

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: vanzhin/coating-monolith

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Деплоим только если build завершился успешно и это был тег
    if: github.event.workflow_run.conclusion == 'success' && startsWith(github.event.workflow_run.head_branch, 'refs/tags/')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract tag name
        id: tag
        run: |
          # Для workflow_run события тег берется из head_branch
          TAG_NAME=${{ github.event.workflow_run.head_branch }}
          # Убираем префикс refs/tags/ если есть
          TAG_NAME=${TAG_NAME#refs/tags/}
          echo "tag=${TAG_NAME}" >> $GITHUB_OUTPUT
          echo "Deploying tag: ${TAG_NAME}"
      
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-php-fpm
          tags: |
            type=ref,event=tag
            type=semver,pattern={{version}}
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Copy docker-compose.prod.yml and .env.example files to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          source: "docker-compose.prod.yml"
          target: "/tmp/"
      - name: Copy .env.example to server
        if: always()
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          source: ".env.example"
          target: "/tmp/"
        continue-on-error: true
      - name: Copy app/.env.example to server
        if: always()
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          source: "app/.env.example"
          target: "/tmp/app.env.example"
        continue-on-error: true
      
      - name: Create Docker context for remote server
        run: |
          docker context create remote --docker "host=ssh://${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" || true
          docker context use remote
      
      - name: Setup .env files on server from .env.example
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: 22
          script: |
            cd /var/www/sites/1helper
            
            # Function to set or update environment variable in a file
            set_env_var() {
              env_file="$1"
              key="$2"
              value="$3"
              # Escape special characters in value
              escaped_value=$(printf '%s\n' "$value" | sed 's/[[\.*^\\$()+?{|]/\\\\&/g')
              
              if grep -q "^${key}=" "$env_file" 2>/dev/null; then
                # Key exists, update it (preserve existing non-empty value if new value is empty)
                current_val=$(grep "^${key}=" "$env_file" | cut -d'=' -f2- | sed 's/^"//;s/"$//')
                if [ -z "$current_val" ] && [ -n "$value" ]; then
                  # Current value is empty and new value is not empty, update it
                  sed -i "s|^${key}=.*|${key}=${escaped_value}|" "$env_file"
                elif [ -n "$value" ]; then
                  # Both values exist, update with new value
                  sed -i "s|^${key}=.*|${key}=${escaped_value}|" "$env_file"
                fi
              else
                # Key doesn't exist, append it
                if [ -n "$value" ]; then
                  echo "${key}=${escaped_value}" >> "$env_file"
                fi
              fi
            }
            
            # Create .env in root (for docker-compose)
            if [ -f .env ]; then
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
            fi
            
            if [ -f /tmp/.env.example ]; then
              echo "Creating .env from .env.example template (docker-compose)..."
              cp /tmp/.env.example .env
            else
              echo ".env.example not found, creating .env from scratch (docker-compose)..."
              touch .env
            fi
            
            # Set docker-compose variables
            set_env_var .env REGISTRY "${{ env.REGISTRY }}"
            set_env_var .env IMAGE_NAME "${{ env.IMAGE_NAME }}"
            set_env_var .env IMAGE_TAG "${{ steps.tag.outputs.tag }}"
            set_env_var .env DOMAIN "${{ vars.DOMAIN }}"
            set_env_var .env HOST_NGINX "${{ vars.HOST_NGINX }}"
            set_env_var .env NETWORK "${{ vars.NETWORK }}"
            set_env_var .env DB_HOST "${{ vars.DB_HOST }}"
            set_env_var .env DB_PORT "${{ vars.DB_PORT }}"
            set_env_var .env DB_NAME "${{ vars.DB_NAME }}"
            set_env_var .env DB_USER "${{ vars.DB_USER }}"
            set_env_var .env DB_PASSWORD "${{ secrets.DB_PASSWORD }}"
            set_env_var .env DB_EXTERNAL_PORT "${{ vars.DB_EXTERNAL_PORT }}"
            set_env_var .env ELASTIC_CONTAINER_NAME "${{ vars.ELASTIC_CONTAINER_NAME }}"
            set_env_var .env INSTALL_XDEBUG "${{ vars.INSTALL_XDEBUG }}"
            set_env_var .env REDIS_HOST "${{ vars.REDIS_HOST }}"
            chmod 600 .env
            
            # Create app/.env (for Symfony application)
            mkdir -p app
            if [ -f app/.env ]; then
              cp app/.env app/.env.backup.$(date +%Y%m%d_%H%M%S)
            fi
            
            if [ -f /tmp/app.env.example ]; then
              echo "Creating app/.env from app/.env.example template (Symfony)..."
              cp /tmp/app.env.example app/.env
            else
              echo "app/.env.example not found, creating app/.env from scratch (Symfony)..."
              touch app/.env
            fi
            
            # Set Symfony application variables (APP_SECRET, JWT keys, etc.)
            set_env_var app/.env APP_ENV "prod"
            set_env_var app/.env APP_DEBUG "0"
            set_env_var app/.env APP_SECRET "${{ secrets.APP_SECRET }}"
            set_env_var app/.env APP_NAME "${{ vars.APP_NAME }}"
            set_env_var app/.env DEFAULT_FROM_ADDR "${{ vars.DEFAULT_FROM_ADDR }}"
            set_env_var app/.env DEFAULT_FROM_NAME "${{ vars.DEFAULT_FROM_NAME }}"
            set_env_var app/.env MAILER_DSN "${{ vars.MAILER_DSN }}"
            set_env_var app/.env JWT_SECRET_KEY "${{ vars.JWT_SECRET_KEY }}"
            set_env_var app/.env JWT_PUBLIC_KEY "${{ vars.JWT_PUBLIC_KEY }}"
            set_env_var app/.env JWT_PASSPHRASE "${{ secrets.JWT_PASSPHRASE }}"
            set_env_var app/.env LOG_TELEGRAM_BOT_KEY "${{ secrets.LOG_TELEGRAM_BOT_KEY }}"
            set_env_var app/.env LOG_TELEGRAM_CHANNEL "${{ vars.LOG_TELEGRAM_CHANNEL }}"
            set_env_var app/.env DATABASE_URL "postgresql://${{ vars.DB_USER }}:${{ secrets.DB_PASSWORD }}@${{ vars.DB_HOST }}:${{ vars.DB_PORT }}/${{ vars.DB_NAME }}"
            set_env_var app/.env REDIS_HOST "${{ vars.REDIS_HOST }}"
            set_env_var app/.env ELASTIC_DSN "${{ vars.ELASTIC_DSN }}"
            set_env_var app/.env ELASTIC_USERNAME "${{ vars.ELASTIC_USERNAME }}"
            set_env_var app/.env ELASTIC_PASSWORD "${{ secrets.ELASTIC_PASSWORD }}"
            chmod 600 app/.env
            
            # Copy docker-compose.prod.yml if needed
            if [ ! -f docker-compose.prod.yml ] || ! cmp -s /tmp/docker-compose.prod.yml docker-compose.prod.yml; then
              cp /tmp/docker-compose.prod.yml docker-compose.prod.yml
            fi
            
            # Clean up temp files
            rm -f /tmp/.env.example /tmp/app.env.example /tmp/docker-compose.prod.yml
      
      - name: Pull latest Docker images
        run: |
          docker --context remote compose -f docker-compose.prod.yml --env-file .env pull
      
      - name: Start containers
        run: |
          docker --context remote compose -f docker-compose.prod.yml --env-file .env up -d --remove-orphans
      
      - name: Wait for containers to be ready
        run: |
          sleep 15
      
      - name: Clear and warm up cache
        run: |
          docker --context remote compose -f docker-compose.prod.yml --env-file .env run --rm manager_php-cli php bin/console cache:clear --env=prod
          docker --context remote compose -f docker-compose.prod.yml --env-file .env run --rm manager_php-cli php bin/console cache:warmup --env=prod
      
      - name: Restart supervisor
        run: |
          docker --context remote compose -f docker-compose.prod.yml --env-file .env restart manager_supervisor || true
      
      - name: Verify containers status
        run: |
          docker --context remote compose -f docker-compose.prod.yml --env-file .env ps
          
          # Check for failed containers
          FAILED=$(docker --context remote compose -f docker-compose.prod.yml --env-file .env ps --filter "status=exited" --filter "status=dead" --format "{{.Name}}" || true)
          if [ -n "$FAILED" ]; then
            echo "❌ ERROR: Some containers failed:"
            echo "$FAILED"
            exit 1
          fi
      
      - name: Cleanup
        if: always()
        run: |
          rm -rf ~/.ssh
          docker context rm remote || true
